(ns com.manigfeald.match)

(defprotocol Pattern
  "Rows are turned in to patterns, code is generated by pulling guards
  and bindings from patterns"
  (guard [pattern value])
  (bindings [pattern value]))

(defrecord Constant [const]
  Pattern
  (guard [_ value]
    `(= ~value ~const))
  (bindings [pattern value]
    []))

(defrecord Binding [name]
  Pattern
  (guard [_ value]
    true)
  (bindings [_ value]
    (if (= (clojure.core/name name) "_")
      `[]
      `[[~name ~value]])))

(defrecord Expression [pat expression]
  Pattern
  (guard [_ value]
    `(and ~(guard pat value)
          (let [~@(apply concat (bindings pat value))]
            ~expression)))
  (bindings [_ value]
    (bindings pat value)))

(defrecord And [patterns]
  Pattern
  (guard [pattern values]
    `(and (sequential? ~values)
          ~@(map-indexed (fn [i pat] (guard pat `(nth ~values ~i))) patterns)
          ~@(for [[name bindings] (group-by first (bindings pattern values))
                  :when (> (count bindings) 1)]
              `(= ~@(map second bindings)))
          (= (count ~values) ~(count patterns))))
  (bindings [pattern values]
    (->> patterns
         (map-indexed (fn [i pat] (bindings pat `(nth ~values ~i))))
         (apply concat))))

(defmulti to-pattern type)

(defmethod to-pattern :default [row] (->Constant row))

(defmethod to-pattern clojure.lang.Symbol [row] (->Binding row))

(defmulti to-pattern-seq (fn [s]
                           (if (symbol? (first s))
                             (if-let [v (resolve (first s))]
                               (let [s (.sym v)
                                     n (.ns v)]
                                 (symbol (name (ns-name n))
                                         (name s)))
                               (first s))
                             (first s))))

(defmethod to-pattern-seq 'quote [row]
  (assert (= 2 (count row)))
  (->Constant row))

(defmethod to-pattern-seq 'clojure.core/quote [row]
  (assert (= 2 (count row)))
  (->Constant row))

(defmethod to-pattern-seq 'clojure.core/cons [row]
  (assert (= 3 (count row)))
  (let [[_ car cdr] row
        car-pat (to-pattern car)
        cdr-pat (to-pattern cdr)]
    (reify
      Pattern
      (guard [pattern value]
        `(and (sequential? ~value)
              ~(guard car-pat `(first ~value))
              ~(guard cdr-pat `(next ~value))))
      (bindings [pattern value]
        (concat
         (bindings car-pat `(first ~value))
         (bindings cdr-pat `(next ~value)))))))

(defmethod to-pattern-seq 'cons [row]
  (assert (= 3 (count row)))
  (to-pattern-seq `(cons ~(nth row 1) ~(nth row 2))))

(defmethod to-pattern-seq :default [row]
  (->Expression (to-pattern (first row)) `(do ~@(rest row))))

(defmethod to-pattern clojure.lang.ISeq [row]
  (if (empty? row)
    (->Constant row)
    (to-pattern-seq row)))

(defmethod to-pattern clojure.lang.IPersistentVector [row]
  (->And (map to-pattern row)))

(defmethod to-pattern clojure.lang.IPersistentMap [row]
  (let [value-patterns (into {} (for [[k v] row] [k (to-pattern v)]))]
    (reify
      Pattern
      (guard [pattern value]
        `(and (map? ~value)
              ~@(for [[k v] value-patterns]
                  (guard v `(get ~value ~k)))))
      (bindings [pattern value]
        (for [[k v] value-patterns
              i (bindings v `(get ~value ~k))]
          i)))))

(defmacro match [thing & clauses]
  (assert (even? (count clauses)))
  (let [n (gensym)]
    `(let [~n ~thing]
       (cond
        ~@(for [[row body] (partition-all 2 clauses)
                :let [g (to-pattern row)
                      binds (bindings g n)
                      joins (for [[name bindings] (group-by first binds)
                                    :when (> (count bindings) 1)]
                              `(= ~@(map second bindings)))]
                i [`(and ~(guard g n)
                         ~@joins)
                   `(let [~@(apply concat binds)]
                      ~body)]]
            i)))))
